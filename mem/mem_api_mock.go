// Automatically generated by MockGen. DO NOT EDIT!
// Source: mem_api.go

package mem

import (
	gomock "github.com/golang/mock/gomock"
	time "time"
)

// Mock of HashMap interface
type MockHashMap struct {
	ctrl     *gomock.Controller
	recorder *_MockHashMapRecorder
}

// Recorder for MockHashMap (not exported)
type _MockHashMapRecorder struct {
	mock *MockHashMap
}

func NewMockHashMap(ctrl *gomock.Controller) *MockHashMap {
	mock := &MockHashMap{ctrl: ctrl}
	mock.recorder = &_MockHashMapRecorder{mock}
	return mock
}

func (_m *MockHashMap) EXPECT() *_MockHashMapRecorder {
	return _m.recorder
}

func (_m *MockHashMap) Get(key string) (string, bool) {
	ret := _m.ctrl.Call(_m, "Get", key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

func (_mr *_MockHashMapRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockHashMap) Set(key string, value string) {
	_m.ctrl.Call(_m, "Set", key, value)
}

func (_mr *_MockHashMapRecorder) Set(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Set", arg0, arg1)
}

func (_m *MockHashMap) Delete(key string) bool {
	ret := _m.ctrl.Call(_m, "Delete", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockHashMapRecorder) Delete(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0)
}

func (_m *MockHashMap) Iter() HashIterator {
	ret := _m.ctrl.Call(_m, "Iter")
	ret0, _ := ret[0].(HashIterator)
	return ret0
}

func (_mr *_MockHashMapRecorder) Iter() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Iter")
}

// Mock of HashIterator interface
type MockHashIterator struct {
	ctrl     *gomock.Controller
	recorder *_MockHashIteratorRecorder
}

// Recorder for MockHashIterator (not exported)
type _MockHashIteratorRecorder struct {
	mock *MockHashIterator
}

func NewMockHashIterator(ctrl *gomock.Controller) *MockHashIterator {
	mock := &MockHashIterator{ctrl: ctrl}
	mock.recorder = &_MockHashIteratorRecorder{mock}
	return mock
}

func (_m *MockHashIterator) EXPECT() *_MockHashIteratorRecorder {
	return _m.recorder
}

func (_m *MockHashIterator) Next() (string, string, bool) {
	ret := _m.ctrl.Call(_m, "Next")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(bool)
	return ret0, ret1, ret2
}

func (_mr *_MockHashIteratorRecorder) Next() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Next")
}

func (_m *MockHashIterator) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockHashIteratorRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of List interface
type MockList struct {
	ctrl     *gomock.Controller
	recorder *_MockListRecorder
}

// Recorder for MockList (not exported)
type _MockListRecorder struct {
	mock *MockList
}

func NewMockList(ctrl *gomock.Controller) *MockList {
	mock := &MockList{ctrl: ctrl}
	mock.recorder = &_MockListRecorder{mock}
	return mock
}

func (_m *MockList) EXPECT() *_MockListRecorder {
	return _m.recorder
}

func (_m *MockList) Get(idx int) (string, bool) {
	ret := _m.ctrl.Call(_m, "Get", idx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

func (_mr *_MockListRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockList) Insert(idx int, value string) bool {
	ret := _m.ctrl.Call(_m, "Insert", idx, value)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockListRecorder) Insert(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Insert", arg0, arg1)
}

func (_m *MockList) Delete(idx int) (string, bool) {
	ret := _m.ctrl.Call(_m, "Delete", idx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

func (_mr *_MockListRecorder) Delete(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0)
}

func (_m *MockList) Iter() ListIterator {
	ret := _m.ctrl.Call(_m, "Iter")
	ret0, _ := ret[0].(ListIterator)
	return ret0
}

func (_mr *_MockListRecorder) Iter() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Iter")
}

// Mock of ListIterator interface
type MockListIterator struct {
	ctrl     *gomock.Controller
	recorder *_MockListIteratorRecorder
}

// Recorder for MockListIterator (not exported)
type _MockListIteratorRecorder struct {
	mock *MockListIterator
}

func NewMockListIterator(ctrl *gomock.Controller) *MockListIterator {
	mock := &MockListIterator{ctrl: ctrl}
	mock.recorder = &_MockListIteratorRecorder{mock}
	return mock
}

func (_m *MockListIterator) EXPECT() *_MockListIteratorRecorder {
	return _m.recorder
}

func (_m *MockListIterator) Next() (int, string, bool) {
	ret := _m.ctrl.Call(_m, "Next")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(bool)
	return ret0, ret1, ret2
}

func (_mr *_MockListIteratorRecorder) Next() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Next")
}

func (_m *MockListIterator) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockListIteratorRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of Set interface
type MockSet struct {
	ctrl     *gomock.Controller
	recorder *_MockSetRecorder
}

// Recorder for MockSet (not exported)
type _MockSetRecorder struct {
	mock *MockSet
}

func NewMockSet(ctrl *gomock.Controller) *MockSet {
	mock := &MockSet{ctrl: ctrl}
	mock.recorder = &_MockSetRecorder{mock}
	return mock
}

func (_m *MockSet) EXPECT() *_MockSetRecorder {
	return _m.recorder
}

func (_m *MockSet) Exists(key string) bool {
	ret := _m.ctrl.Call(_m, "Exists", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSetRecorder) Exists(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Exists", arg0)
}

func (_m *MockSet) Insert(key string) bool {
	ret := _m.ctrl.Call(_m, "Insert", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSetRecorder) Insert(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Insert", arg0)
}

func (_m *MockSet) Iter() SetIterator {
	ret := _m.ctrl.Call(_m, "Iter")
	ret0, _ := ret[0].(SetIterator)
	return ret0
}

func (_mr *_MockSetRecorder) Iter() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Iter")
}

// Mock of SetIterator interface
type MockSetIterator struct {
	ctrl     *gomock.Controller
	recorder *_MockSetIteratorRecorder
}

// Recorder for MockSetIterator (not exported)
type _MockSetIteratorRecorder struct {
	mock *MockSetIterator
}

func NewMockSetIterator(ctrl *gomock.Controller) *MockSetIterator {
	mock := &MockSetIterator{ctrl: ctrl}
	mock.recorder = &_MockSetIteratorRecorder{mock}
	return mock
}

func (_m *MockSetIterator) EXPECT() *_MockSetIteratorRecorder {
	return _m.recorder
}

func (_m *MockSetIterator) Next() (string, bool) {
	ret := _m.ctrl.Call(_m, "Next")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

func (_mr *_MockSetIteratorRecorder) Next() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Next")
}

func (_m *MockSetIterator) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockSetIteratorRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of MemCtrl interface
type MockMemCtrl struct {
	ctrl     *gomock.Controller
	recorder *_MockMemCtrlRecorder
}

// Recorder for MockMemCtrl (not exported)
type _MockMemCtrlRecorder struct {
	mock *MockMemCtrl
}

func NewMockMemCtrl(ctrl *gomock.Controller) *MockMemCtrl {
	mock := &MockMemCtrl{ctrl: ctrl}
	mock.recorder = &_MockMemCtrlRecorder{mock}
	return mock
}

func (_m *MockMemCtrl) EXPECT() *_MockMemCtrlRecorder {
	return _m.recorder
}

func (_m *MockMemCtrl) Get(key string) (string, bool, error) {
	ret := _m.ctrl.Call(_m, "Get", key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockMemCtrlRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockMemCtrl) SetEx(key string, value string, ttl time.Duration) {
	_m.ctrl.Call(_m, "SetEx", key, value, ttl)
}

func (_mr *_MockMemCtrlRecorder) SetEx(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetEx", arg0, arg1, arg2)
}

func (_m *MockMemCtrl) Delete(key string) bool {
	ret := _m.ctrl.Call(_m, "Delete", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockMemCtrlRecorder) Delete(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0)
}

func (_m *MockMemCtrl) Expire(key string, ttl time.Duration) bool {
	ret := _m.ctrl.Call(_m, "Expire", key, ttl)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockMemCtrlRecorder) Expire(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Expire", arg0, arg1)
}

func (_m *MockMemCtrl) Hash(key string) (HashMap, error) {
	ret := _m.ctrl.Call(_m, "Hash", key)
	ret0, _ := ret[0].(HashMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockMemCtrlRecorder) Hash(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Hash", arg0)
}

func (_m *MockMemCtrl) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockMemCtrlRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}
